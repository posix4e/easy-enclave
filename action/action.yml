name: 'Easy Enclave Attest'
description: 'Deploy workload in TDX VM and create attested GitHub release'
inputs:
  agent-url:
    description: 'URL of the deployment agent (if not provided, runs locally on self-hosted TDX runner)'
    required: false
  docker-compose:
    description: 'Path to docker-compose.yml'
    required: false
    default: './docker-compose.yml'
  public-env:
    description: 'Public env vars (KEY=VALUE, newline separated) to include in the bundle artifact'
    required: false
    default: ''
  private-env:
    description: 'Private env vars (KEY=VALUE, newline separated) sent inline to the agent'
    required: false
    default: ''
  public-files:
    description: 'Public file or directory paths to include in the bundle artifact (comma or newline separated)'
    required: false
    default: ''
  bundle-inline:
    description: 'Send bundle inline to the agent instead of uploading an artifact'
    required: false
    default: 'false'
  seal-vm:
    description: 'Seal VM access after deployment (disable SSH and serial getty)'
    required: false
    default: 'true'
  endpoint:
    description: 'Public endpoint URL for the service (use "auto" for http://{vm_ip}:8080)'
    required: false
    default: 'auto'
  endpoint-port:
    description: 'Port for auto-generated endpoint (used when endpoint is "auto")'
    required: false
    default: '8080'
  github-token:
    description: 'GitHub token for creating releases'
    required: true
    default: ${{ github.token }}
  agent-release-tag:
    description: 'Release tag that provides agent attestation allowlist'
    required: false
    default: ''
  agent-allowlist-asset:
    description: 'Release asset name for agent allowlist JSON'
    required: false
    default: 'agent-attestation-allowlist.json'
  agent-attestation-skip-pccs:
    description: 'Skip PCCS verification for agent attestation'
    required: false
    default: 'false'
  agent-attestation-timeout:
    description: 'Timeout in seconds for agent attestation fetch'
    required: false
    default: '10'
  agent-skip-attestation:
    description: 'Skip agent attestation checks (development only)'
    required: false
    default: 'false'
  agent-attestation-via-ssh:
    description: 'Fetch attestation via SSH to the host (uses agent-ssh-*)'
    required: false
    default: 'false'
  agent-ssh-host:
    description: 'SSH host for agent VM provisioning'
    required: false
    default: ''
  agent-ssh-user:
    description: 'SSH user for agent VM provisioning'
    required: false
    default: 'ubuntu'
  agent-ssh-key:
    description: 'SSH private key for agent VM provisioning'
    required: false
    default: ''
  agent-ssh-port:
    description: 'SSH port for agent VM provisioning'
    required: false
    default: '22'
  agent-vm-ref:
    description: 'Git ref to use when provisioning the agent VM'
    required: false
    default: 'main'
  agent-vm-name:
    description: 'Agent VM name to provision'
    required: false
    default: 'ee-attestor'
  agent-vm-port:
    description: 'Agent VM port'
    required: false
    default: '8000'
  agent-vm-image-tag:
    description: 'VM image tag for the agent VM'
    required: false
    default: ''
  agent-vm-image-sha256:
    description: 'VM image sha256 for the agent VM'
    required: false
    default: ''
  vm-name:
    description: 'Name for the TD VM'
    required: false
    default: 'ee-workload'
  cleanup-prefixes:
    description: 'Comma-separated VM name prefixes to cleanup before deployment (agent mode only)'
    required: false
    default: ''
  enable-ssh:
    description: 'Enable SSH access to VM (default: false)'
    required: false
    default: 'false'
  github-developer:
    description: 'GitHub username to pull public SSH keys from'
    required: false
    default: ''
  unseal-password:
    description: 'Password to enable SSH access (set in guest as ubuntu)'
    required: false
    default: ''
outputs:
  vm_ip:
    description: 'IP address of the created TD VM'
    value: ${{ steps.set-outputs.outputs.vm_ip }}
  quote:
    description: 'Base64-encoded TDX quote'
    value: ${{ steps.set-outputs.outputs.quote }}
  release_url:
    description: 'URL of the created GitHub release'
    value: ${{ steps.set-outputs.outputs.release_url }}
runs:
  using: 'composite'
  steps:
    # Agent mode: call remote agent API
    - name: Resolve agent URL
      id: agent-url
      if: ${{ inputs.agent-url != '' }}
      shell: bash
      run: |
        set -euo pipefail
        URL="${{ inputs.agent-url }}"
        if [ "${{ inputs.agent-attestation-via-ssh }}" = "true" ] && [ -n "${{ inputs.agent-ssh-host }}" ] && [ -n "${{ inputs.agent-ssh-key }}" ]; then
          KEY_FILE=$(mktemp)
          chmod 600 "$KEY_FILE"
          printf '%s\n' "${{ inputs.agent-ssh-key }}" > "$KEY_FILE"
          IP=$(ssh -o StrictHostKeyChecking=no -p "${{ inputs.agent-ssh-port }}" -i "$KEY_FILE" \
            "${{ inputs.agent-ssh-user }}@${{ inputs.agent-ssh-host }}" \
            "sudo virsh domifaddr \"${{ inputs.agent-vm-name }}\" --source lease | awk '/ipv4/ {print \$4}' | head -n1 | cut -d/ -f1")
          if [ -z "$IP" ]; then
            IP=$(ssh -o StrictHostKeyChecking=no -p "${{ inputs.agent-ssh-port }}" -i "$KEY_FILE" \
              "${{ inputs.agent-ssh-user }}@${{ inputs.agent-ssh-host }}" \
              "sudo virsh net-dhcp-leases default | awk -v n=\"${{ inputs.agent-vm-name }}\" '\\$0 ~ n && /ipv4/ {print \$5}' | head -n1 | cut -d/ -f1")
          fi
          if [ -z "$IP" ]; then
            echo "Could not determine IP for ${{ inputs.agent-vm-name }}" >&2
            exit 1
          fi
          TUNNEL_PORT=18000
          ssh -o StrictHostKeyChecking=no -o ExitOnForwardFailure=yes -p "${{ inputs.agent-ssh-port }}" -i "$KEY_FILE" \
            -fN -L "${TUNNEL_PORT}:${IP}:${{ inputs.agent-vm-port }}" \
            "${{ inputs.agent-ssh-user }}@${{ inputs.agent-ssh-host }}"
          rm -f "$KEY_FILE"
          URL="http://127.0.0.1:${TUNNEL_PORT}"
        fi
        echo "url=$URL" >> "$GITHUB_OUTPUT"
    - name: Check agent URL
      if: ${{ inputs.agent-url != '' && inputs.agent-attestation-via-ssh != 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        URL="${{ steps.agent-url.outputs.url }}"
        if ! curl -sf --connect-timeout 5 --max-time 10 "$URL/health" >/dev/null; then
          echo "::error::Agent URL health check failed: $URL/health" >&2
          exit 1
        fi
        if ! curl -sf --connect-timeout 5 --max-time 10 "$URL/attestation" >/dev/null; then
          echo "::error::Agent URL attestation check failed: $URL/attestation" >&2
          exit 1
        fi
    - name: Ensure agent VM
      if: ${{ inputs.agent-url != '' && inputs.agent-ssh-host != '' && inputs.agent-ssh-key != '' }}
      shell: bash
      run: |
        set -euo pipefail
        if curl -sf "${{ steps.agent-url.outputs.url }}/health" >/dev/null; then
          echo "Agent reachable"
          exit 0
        fi
        if [ -z "${{ inputs.agent-vm-image-tag }}" ] || [ -z "${{ inputs.agent-vm-image-sha256 }}" ]; then
          echo "::error::agent-vm-image-tag and agent-vm-image-sha256 are required to provision agent VM"
          exit 1
        fi
        echo "Provisioning agent VM via SSH..."
        KEY_FILE=$(mktemp)
        chmod 600 "$KEY_FILE"
        printf '%s\n' "${{ inputs.agent-ssh-key }}" > "$KEY_FILE"
        ssh -o StrictHostKeyChecking=no -p "${{ inputs.agent-ssh-port }}" -i "$KEY_FILE" \
          "${{ inputs.agent-ssh-user }}@${{ inputs.agent-ssh-host }}" \
          "set -euo pipefail; \
           sudo mkdir -p /opt/easy-enclave; \
           if [ ! -d /opt/easy-enclave/.git ]; then sudo git clone https://github.com/${{ github.repository }}.git /opt/easy-enclave; fi; \
           cd /opt/easy-enclave; \
           sudo git fetch --tags origin; \
           sudo git checkout ${{ inputs.agent-vm-ref }}; \
           sudo python3 installer/host.py --agent \
             --name \"${{ inputs.agent-vm-name }}\" \
             --port \"${{ inputs.agent-vm-port }}\" \
             --vm-image-tag \"${{ inputs.agent-vm-image-tag }}\" \
             --vm-image-sha256 \"${{ inputs.agent-vm-image-sha256 }}\""
        rm -f "$KEY_FILE"
    - name: Fetch agent allowlist
      id: agent-allowlist
      if: ${{ inputs.agent-url != '' && inputs.agent-skip-attestation != 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        if [ -z "${{ inputs.agent-release-tag }}" ]; then
          echo "::error::agent-release-tag is required for agent attestation"
          exit 1
        fi
        RELEASE_JSON=$(curl -sf \
          -H "Authorization: Bearer ${{ inputs.github-token }}" \
          -H "Accept: application/vnd.github+json" \
          "https://api.github.com/repos/${{ github.repository }}/releases/tags/${{ inputs.agent-release-tag }}")
        ASSET_URL=$(echo "$RELEASE_JSON" | jq -r --arg name "${{ inputs.agent-allowlist-asset }}" '.assets[] | select(.name==$name) | .browser_download_url')
        if [ -z "$ASSET_URL" ] || [ "$ASSET_URL" = "null" ]; then
          echo "::error::Allowlist asset not found: ${{ inputs.agent-allowlist-asset }}"
          exit 1
        fi
        curl -sfL -o /tmp/agent_allowlist.json "$ASSET_URL"

    - name: Verify agent attestation (pre)
      if: ${{ inputs.agent-url != '' && inputs.agent-skip-attestation != 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        python3 -m pip install "${{ github.action_path }}/../sdk"
        ATTEST_ARGS=(--attestation-url "${{ steps.agent-url.outputs.url }}/attestation")
        if [ "${{ inputs.agent-attestation-via-ssh }}" = "true" ] && [ -n "${{ inputs.agent-ssh-host }}" ] && [ -n "${{ inputs.agent-ssh-key }}" ]; then
          KEY_FILE=$(mktemp)
          chmod 600 "$KEY_FILE"
          printf '%s\n' "${{ inputs.agent-ssh-key }}" > "$KEY_FILE"
          IP=$(ssh -o StrictHostKeyChecking=no -p "${{ inputs.agent-ssh-port }}" -i "$KEY_FILE" \
            "${{ inputs.agent-ssh-user }}@${{ inputs.agent-ssh-host }}" \
            "sudo virsh domifaddr \"${{ inputs.agent-vm-name }}\" --source lease | awk '/ipv4/ {print \$4}' | head -n1 | cut -d/ -f1")
          if [ -z "$IP" ]; then
            IP=$(ssh -o StrictHostKeyChecking=no -p "${{ inputs.agent-ssh-port }}" -i "$KEY_FILE" \
              "${{ inputs.agent-ssh-user }}@${{ inputs.agent-ssh-host }}" \
              "sudo virsh net-dhcp-leases default | awk -v n=\"${{ inputs.agent-vm-name }}\" '\\$0 ~ n && /ipv4/ {print \$5}' | head -n1 | cut -d/ -f1")
          fi
          if [ -z "$IP" ]; then
            echo "Could not determine IP for ${{ inputs.agent-vm-name }}" >&2
            exit 1
          fi
          ssh -o StrictHostKeyChecking=no -p "${{ inputs.agent-ssh-port }}" -i "$KEY_FILE" \
            "${{ inputs.agent-ssh-user }}@${{ inputs.agent-ssh-host }}" \
            "curl -sf \"http://$IP:${{ inputs.agent-vm-port }}/attestation\"" > /tmp/agent_attestation.json
          rm -f "$KEY_FILE"
          ATTEST_ARGS=(--attestation-file /tmp/agent_attestation.json)
        fi
        python3 "${{ github.action_path }}/src/verify_agent_attestation.py" \
          --allowlist /tmp/agent_allowlist.json \
          "${ATTEST_ARGS[@]}" \
          --timeout "${{ inputs.agent-attestation-timeout }}" \
          ${{ inputs.agent-attestation-skip-pccs == 'true' && '--skip-pccs' || '' }}
    - name: Build public bundle
      id: bundle
      if: ${{ inputs.agent-url != '' }}
      shell: bash
      run: |
        set -euo pipefail
        BUNDLE_DIR=$(mktemp -d)
        COMPOSE_SRC="${{ inputs.docker-compose }}"
        COMPOSE_DIR=$(dirname "$COMPOSE_SRC")
        COMPOSE_DIR="${COMPOSE_DIR#./}"
        if [ -z "$COMPOSE_DIR" ] || [ "$COMPOSE_DIR" = "." ]; then
          cp "$COMPOSE_SRC" "$BUNDLE_DIR/docker-compose.yml"
        else
          cp -a --parents -- "$COMPOSE_DIR" "$BUNDLE_DIR/"
        fi

        if [ -n "${{ inputs.public-env }}" ]; then
          printf '%s\n' "${{ inputs.public-env }}" > "$BUNDLE_DIR/.env.public"
        fi

        if [ -n "${{ inputs.github-developer }}" ]; then
          if curl -fsSL "https://github.com/${{ inputs.github-developer }}.keys" -o "$BUNDLE_DIR/authorized_keys"; then
            if [ ! -s "$BUNDLE_DIR/authorized_keys" ]; then
              echo "Warning: no public keys found for ${{ inputs.github-developer }}"
              rm -f "$BUNDLE_DIR/authorized_keys"
            fi
          else
            echo "Warning: failed to fetch keys for ${{ inputs.github-developer }}"
            rm -f "$BUNDLE_DIR/authorized_keys"
          fi
        fi

        if [ -n "${{ inputs.public-files }}" ]; then
          printf '%s\n' "${{ inputs.public-files }}" | tr ',' '\n' | while IFS= read -r path || [ -n "$path" ]; do
            path="$(printf '%s' "$path" | xargs)"
            [ -z "$path" ] && continue
            cp -a --parents -- "$path" "$BUNDLE_DIR/"
          done
        fi

        echo "bundle_dir=$BUNDLE_DIR" >> $GITHUB_OUTPUT

    - name: Upload public bundle
      id: bundle-upload
      if: ${{ inputs.agent-url != '' && inputs.bundle-inline != 'true' }}
      uses: actions/upload-artifact@v4
      with:
        name: ee-deploy-bundle-${{ github.run_id }}-${{ github.job }}
        path: ${{ steps.bundle.outputs.bundle_dir }}
        if-no-files-found: error

    - name: Deploy via Agent
      id: agent
      if: ${{ inputs.agent-url != '' }}
      shell: bash
      run: |
        echo "Deploying via agent at ${{ steps.agent-url.outputs.url }}"

        CLEANUP_PREFIXES_JSON="null"
        if [ -n "${{ inputs.cleanup-prefixes }}" ]; then
          CLEANUP_PREFIXES_JSON=$(printf '%s' "${{ inputs.cleanup-prefixes }}" | jq -R 'split(",") | map(gsub("^\\s+|\\s+$";"")) | map(select(length>0))')
        fi
        ENABLE_SSH="false"
        if [ "${{ inputs.enable-ssh }}" = "true" ] || [ -n "${{ inputs.github-developer }}" ] || [ -n "${{ inputs.unseal-password }}" ]; then
          ENABLE_SSH="true"
        fi
        EFFECTIVE_SEAL="${{ inputs.seal-vm }}"
        if [ "$ENABLE_SSH" = "true" ]; then
          EFFECTIVE_SEAL="false"
        fi
        PRIVATE_ENV_VALUE="${{ inputs.private-env }}"
        append_env() {
          if [ -n "$PRIVATE_ENV_VALUE" ]; then
            PRIVATE_ENV_VALUE="${PRIVATE_ENV_VALUE}"$'\n'"$1"
          else
            PRIVATE_ENV_VALUE="$1"
          fi
        }
        if [ -n "${{ inputs.unseal-password }}" ]; then
          append_env "UNSEAL_PASSWORD=${{ inputs.unseal-password }}"
        fi
        if [ "$ENABLE_SSH" = "true" ]; then
          if ! printf '%s\n' "$PRIVATE_ENV_VALUE" | grep -q '^ENABLE_SSH='; then
            append_env "ENABLE_SSH=true"
          fi
        fi
        if [ "$EFFECTIVE_SEAL" = "true" ]; then
          if ! printf '%s\n' "$PRIVATE_ENV_VALUE" | grep -q '^SEAL_VM='; then
            append_env "SEAL_VM=true"
          fi
        fi
        PRIVATE_ENV_JSON="null"
        if [ -n "$PRIVATE_ENV_VALUE" ]; then
          PRIVATE_ENV_JSON=$(printf '%s' "$PRIVATE_ENV_VALUE" | jq -Rs '.')
        fi

        BUNDLE_B64_FILE="/dev/null"
        BUNDLE_FORMAT=""
        if [ "${{ inputs.bundle-inline }}" = "true" ]; then
          BUNDLE_DIR="${{ steps.bundle.outputs.bundle_dir }}"
          if [ -z "$BUNDLE_DIR" ]; then
            echo "::error::bundle_dir missing for inline bundle"
            exit 1
          fi
          ARCHIVE_PATH=$(mktemp)
          tar -czf "$ARCHIVE_PATH" -C "$BUNDLE_DIR" .
          BUNDLE_B64_FILE=$(mktemp)
          base64 -w 0 "$ARCHIVE_PATH" > "$BUNDLE_B64_FILE"
          BUNDLE_FORMAT="tar.gz"
          rm -f "$ARCHIVE_PATH"
        fi

        BUNDLE_ARTIFACT_JSON="null"
        if [ -n "${{ steps.bundle-upload.outputs.artifact-id }}" ]; then
          BUNDLE_ARTIFACT_JSON="${{ steps.bundle-upload.outputs.artifact-id }}"
        fi

        # Start deployment
        SEAL_VM_JSON="false"
        if [ "$EFFECTIVE_SEAL" = "true" ]; then
          SEAL_VM_JSON="true"
        fi

        PAYLOAD=$(jq -n \
          --arg repo "${{ github.repository }}" \
          --argjson port ${{ inputs.endpoint-port }} \
          --arg vm_name "${{ inputs.vm-name }}" \
          --argjson cleanup_prefixes "$CLEANUP_PREFIXES_JSON" \
          --argjson bundle_artifact_id "$BUNDLE_ARTIFACT_JSON" \
          --rawfile bundle_b64 "$BUNDLE_B64_FILE" \
          --arg bundle_format "$BUNDLE_FORMAT" \
          --argjson private_env "$PRIVATE_ENV_JSON" \
          --argjson seal_vm "$SEAL_VM_JSON" \
          '{repo:$repo, port:$port, vm_name:$vm_name, seal_vm:$seal_vm}
           + (if $bundle_artifact_id == null then {} else {bundle_artifact_id:$bundle_artifact_id} end)
           + (if $bundle_b64 == "" then {} else {bundle_b64:$bundle_b64, bundle_format:$bundle_format} end)
           + (if $cleanup_prefixes == null then {} else {cleanup_prefixes:$cleanup_prefixes} end)
           + (if $private_env == null then {} else {private_env:$private_env} end)')

        if [ "$BUNDLE_B64_FILE" != "/dev/null" ]; then
          rm -f "$BUNDLE_B64_FILE"
        fi

        RESPONSE=$(curl -sf -X POST "${{ steps.agent-url.outputs.url }}/deploy" \
          -H "Authorization: Bearer ${{ inputs.github-token }}" \
          -H "Content-Type: application/json" \
          -d "$PAYLOAD")

        DEPLOY_ID=$(echo "$RESPONSE" | jq -r .deployment_id)
        echo "Deployment started: $DEPLOY_ID"

        # Poll for completion
        MAX_WAIT=600
        WAITED=0
        while [ $WAITED -lt $MAX_WAIT ]; do
          STATUS_RESPONSE=$(curl -sf "${{ steps.agent-url.outputs.url }}/status/$DEPLOY_ID")
          STATUS=$(echo "$STATUS_RESPONSE" | jq -r .status)
          echo "Status: $STATUS (waited ${WAITED}s)"
          SERIAL_LOG=$(echo "$STATUS_RESPONSE" | jq -r '.host_logs.serial // empty')
          QEMU_LOG=$(echo "$STATUS_RESPONSE" | jq -r '.host_logs.qemu // empty')
          if [ -n "$SERIAL_LOG" ]; then
            echo "=== Serial log (tail) ==="
            echo "$SERIAL_LOG"
          fi
          if [ -n "$QEMU_LOG" ]; then
            echo "=== QEMU log (tail) ==="
            echo "$QEMU_LOG"
          fi

          if [ "$STATUS" = "complete" ]; then
            RESULT="$STATUS_RESPONSE"
            echo "vm_ip=$(echo "$RESULT" | jq -r .vm_ip)" >> $GITHUB_OUTPUT
            echo "quote=$(echo "$RESULT" | jq -r .quote)" >> $GITHUB_OUTPUT
            echo "release_url=$(echo "$RESULT" | jq -r .release_url)" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "$STATUS" = "failed" ]; then
            ERROR=$(echo "$STATUS_RESPONSE" | jq -r .error)
            echo "Deployment failed: $ERROR"
            exit 1
          fi

          sleep 10
          WAITED=$((WAITED + 10))
        done

        echo "Deployment timed out after ${MAX_WAIT}s"
        exit 1

    # Local mode: run on self-hosted TDX runner
    - name: Setup TDX environment
      if: ${{ inputs.agent-url == '' }}
      shell: bash
      run: |
        # Force destroy old VM if exists
        sudo virsh destroy ${{ inputs.vm-name }} 2>/dev/null || true
        sudo virsh undefine ${{ inputs.vm-name }} --nvram 2>/dev/null || true
        # Ensure libvirt default network is active
        if ! sudo virsh net-info default 2>/dev/null | grep -q "Active:.*yes"; then
          echo "Starting libvirt default network..."
          sudo virsh net-start default 2>/dev/null || true
        fi
        # Fix vsock permissions for QEMU to connect to QGS
        sudo chmod 666 /dev/vhost-vsock /dev/vsock 2>/dev/null || true

    - name: Create TD VM and Release
      id: vm
      if: ${{ inputs.agent-url == '' }}
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        python3 ${{ github.action_path }}/../installer/host.py ${{ inputs.docker-compose }} \
          --name ${{ inputs.vm-name }} \
          --port ${{ inputs.endpoint-port }} \
          ${{ inputs.enable-ssh == 'true' && '--enable-ssh' || '' }} \
          --create-release \
          ${{ inputs.endpoint != 'auto' && format('--endpoint {0}', inputs.endpoint) || '' }} \
          > /tmp/vm_result.json
        echo "quote=$(jq -r .quote /tmp/vm_result.json)" >> $GITHUB_OUTPUT
        echo "vm_ip=$(jq -r .ip /tmp/vm_result.json)" >> $GITHUB_OUTPUT
        echo "release_url=$(jq -r .release_url /tmp/vm_result.json)" >> $GITHUB_OUTPUT

    # Copy agent outputs to vm outputs for unified interface
    - name: Set outputs
      id: set-outputs
      shell: bash
      run: |
        set -euo pipefail
        VM_IP="${{ steps.agent.outputs.vm_ip }}"
        QUOTE="${{ steps.agent.outputs.quote }}"
        RELEASE_URL="${{ steps.agent.outputs.release_url }}"
        if [ -z "$VM_IP" ]; then
          VM_IP="${{ steps.vm.outputs.vm_ip }}"
        fi
        if [ -z "$QUOTE" ]; then
          QUOTE="${{ steps.vm.outputs.quote }}"
        fi
        if [ -z "$RELEASE_URL" ]; then
          RELEASE_URL="${{ steps.vm.outputs.release_url }}"
        fi
        echo "vm_ip=$VM_IP" >> $GITHUB_OUTPUT
        echo "quote=$QUOTE" >> $GITHUB_OUTPUT
        echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT

    - name: Verify agent attestation (post)
      if: ${{ inputs.agent-url != '' && inputs.agent-skip-attestation != 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        ATTEST_ARGS=(--attestation-url "${{ steps.agent-url.outputs.url }}/attestation")
        if [ "${{ inputs.agent-attestation-via-ssh }}" = "true" ] && [ -n "${{ inputs.agent-ssh-host }}" ] && [ -n "${{ inputs.agent-ssh-key }}" ]; then
          KEY_FILE=$(mktemp)
          chmod 600 "$KEY_FILE"
          printf '%s\n' "${{ inputs.agent-ssh-key }}" > "$KEY_FILE"
          IP=$(ssh -o StrictHostKeyChecking=no -p "${{ inputs.agent-ssh-port }}" -i "$KEY_FILE" \
            "${{ inputs.agent-ssh-user }}@${{ inputs.agent-ssh-host }}" \
            "sudo virsh domifaddr \"${{ inputs.agent-vm-name }}\" --source lease | awk '/ipv4/ {print \$4}' | head -n1 | cut -d/ -f1")
          if [ -z "$IP" ]; then
            IP=$(ssh -o StrictHostKeyChecking=no -p "${{ inputs.agent-ssh-port }}" -i "$KEY_FILE" \
              "${{ inputs.agent-ssh-user }}@${{ inputs.agent-ssh-host }}" \
              "sudo virsh net-dhcp-leases default | awk -v n=\"${{ inputs.agent-vm-name }}\" '\\$0 ~ n && /ipv4/ {print \$5}' | head -n1 | cut -d/ -f1")
          fi
          if [ -z "$IP" ]; then
            echo "Could not determine IP for ${{ inputs.agent-vm-name }}" >&2
            exit 1
          fi
          ssh -o StrictHostKeyChecking=no -p "${{ inputs.agent-ssh-port }}" -i "$KEY_FILE" \
            "${{ inputs.agent-ssh-user }}@${{ inputs.agent-ssh-host }}" \
            "curl -sf \"http://$IP:${{ inputs.agent-vm-port }}/attestation\"" > /tmp/agent_attestation.json
          rm -f "$KEY_FILE"
          ATTEST_ARGS=(--attestation-file /tmp/agent_attestation.json)
        fi
        python3 "${{ github.action_path }}/src/verify_agent_attestation.py" \
          --allowlist /tmp/agent_allowlist.json \
          "${ATTEST_ARGS[@]}" \
          --timeout "${{ inputs.agent-attestation-timeout }}" \
          ${{ inputs.agent-attestation-skip-pccs == 'true' && '--skip-pccs' || '' }}
